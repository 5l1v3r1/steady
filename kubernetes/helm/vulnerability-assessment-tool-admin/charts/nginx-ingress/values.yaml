managedRelease: "alpha"

rbac:
  # _n_ rbac.create
  # _d_ bool to indicate whether or not rbac is required
  # _i_
  # This would create clusterrole and roles required for nginx ingress controller
  # to perform operations accross three namespaces : vulas-core, vulas-admin,
  # and vulas-monitoring
  create: true

# -------------------------- Proxy defaultbackend ------------------------------
defaultBackend:
  # _n_ defaultBackend.enabled
  # _d_ bool to indicate whether or not to create default backend
  enabled: true

  # -------------------------- Base declarations -------------------------------
  # _n_ defaultBackend.replicas
  # _d_ Desired default proxy replicas
  # _i_
  # Suggestion : ~= 1 (returns 404 so useless to duplicate)
  replicas: 1

  selfAntiAffinity: {}
    # soft: true
    # weight: 100

  podDisruptionBudget: {}

  image:
    pullPolicy: "IfNotPresent"
    registry: "gcr.io"
    registryPort: {}
    name: "google_containers/defaultbackend"
    tag: "1.4"
    # _n_ defaultBackend.image.runAsUser
    # _i_
    # defaults to nobody
    runAsUser: 65534

    # ---------------------- Base resources requests ---------------------------
    resources: {}
      # limits:
      #   memory: "60Mi"
      #   cpu: "110m"
      # requests:
      #   memory: "50Mi"
      #   cpu: "100m"

  livenessProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    enabled: true
    initialDelaySeconds: 0
    periodSeconds: 5
    timeoutSeconds: 5
    failureThreshold: 6

#========================== Ingress Controller =================================
ingressController:
  authIngress:
    # _n_ ingressController.authIngress.enabled
    # _d_ enables auth ingress
    # _i_
    # This enables basic auth access to (if present) kibana, frontendbugs, prometheus
    enabled: true
    credentials:
      # _n_ ingressController.authIngress.credentials.user
      # _i_
      # These credentials are generated and encrypted with htpasswd with a
      # poststart helm hook named "nginx-ingress-secret-generator" which
      # communicates with the kubernetes API to modify the corresponding secret
      user: vulas
      # _n_ ingressController.authIngress.credentials.password
      password: vulas

  # -------------------------- Base declarations -------------------------------
  # _n_ ingressController.replicas
  # _d_ Desired nginx ingress controller deployment replicas
  # _i_
  # Suggestion : ~= Depending on load
  # (kubernetes/nginx-ingress controller has internal distribution
  # mechanisms such as elections so it can handle it)
  replicas: 3

  updateStrategy: {}

  # _n_ ingressController.debugLevel
  # _d_ sets logging level
  # _i_
  # Possible values are listed in NGINX's error_log config documentation
  # (see http://nginx.org/en/docs/ngx_core_module.html#error_log)
  debugLevel: error

  # _n_ ingressController.external
  # _d_ allows external load balancer
  external: true
  externalIP: {}

  # _n_ ingressController.electionID
  # _d_ Election ID to use for status update
  electionID: ingress-controller-leader

  # _n_ ingressController.ingressClass
  # _d_ Name of the ingress class to route through this controller
  ingressClass: nginx

  # _n_ ingressController.rbac
  # _d_ enables rbac
  # _i_
  # If rbac is set to {} no clusterrole, role and rolebinding
  # will be created to link up to the desired service account
  rbac: true

  selfAntiAffinity: {}
    # _n_ ingressController.selfAntiAffinity.soft
    # _d_ flag for affinity type
    # _i_
    #     You can set selfAntiAffinity to {} in order to skip
    #     all affinity declarations
    # soft: true
    # _n_ selfAntiAffinity.weight
    # _d_ weight for selfAntiAffinity
    # weight: 100

  podDisruptionBudget: {}
  persistentVolume: {}

  # ---------------------------- Base images -----------------------------------
  image:
    pullPolicy: "IfNotPresent"
    registry: "quay.io"
    registryPort: {}
    name: "kubernetes-ingress-controller/nginx-ingress-controller"
    tag: "0.25.0"
    runAsUser: {}
    allowPrivilegeEscalation: true

    # ---------------------- Base resources requests ---------------------------
    resources: {}
      # limits:
      #   memory: "500Mi"
      #   cpu: "500m"
      # requests:
      #   memory: "50Mi"
      #   cpu: "50m"


  livenessProbe:
    # _n_ ingressController.livenessProbe.enabled
    # _i_
    # Overall time before container is considered unready by k8s :
    # initialDelaySeconds + ((periodSeconds + timeoutSeconds) * successThreshold)
    # = 510s ~= 8.5min
    enabled: true
    initialDelaySeconds: 15
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 10
    successThreshold: 1

  readinessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 60
    timeoutSeconds: 5
    failureThreshold: 10
    successThreshold: 2
    path: /healthz
