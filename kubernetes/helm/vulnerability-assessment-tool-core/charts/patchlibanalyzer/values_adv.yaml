replicas: 3

deployment:
  # _n_ deployment.enabled
  # _i_
  # if enabled:false this will create a cronjob rather than
  # a deployment.
  enabled: false

cronJob:
  # _n_ cronJob.period
  # _i_
  # If set to {} defaults to 23h
  period: {}

  # _n_ cronJob.bugs
  # _i_
  # If set to {} defaults to ""
  bugs: {}
  delay: {}

# _n_ startUpDelay
# _d_ Delay before the initContainer starts probing using pg_isready
startUpDelay: 5
# _n_ backoffDuration
# _d_ Delay between probing attempts
backoffDuration: 5

podNetworkPolicy:
  enabled: true

podPriorityClass:
  # _n_ podPriorityClass.spec
  # _i_
  # If .Values.global.podPriorityClass.enabled and spec is {}
  # defaults to
  #   globalDefault: false
  #   value: 400
  #   preemptionPolicy: Never
  spec: {}

extraConfigs: {}
extraSecrets: {}

# _n_ debug
# _i_
# Sets logging level for shell scripts as well as jar
debug: false

podDisruptionBudget: {}
  # _n_ podDisruptionBudget.minAvailable
  # _i_
  #    Warning :  this won't be applied unless the replicas
  #               values are >= 2
  # minAvailable: 1

selfAntiAffinity:
  # _n_ selfAntiAffinity.soft
  # _i_
  #     You can set selfAntiAffinity to {} in order to skip
  #     all affinity declarations in the statefulset
  soft: true
  weight: 100

#================================= Image =======================================
image:
  initContainer:
    pullPolicy: "IfNotPresent"
    registry: {}
    registryPort: {}
    # _n_ image.initContainer.name
    # _i_
    name: "postgres"
    # _n_ image.initContainer.tag
    # _i_
    # Alpine images for init container to reduce
    # overal resource strain with Image size: 28MBs
    tag: "11.3-alpine"

    securityContext:
      runAsUser: 65534
      runAsGroup: 65534
      privileged: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
          - ALL
        add:
          - SYS_TIME
          - NET_ADMIN

    resources:
      limits:
        memory: "35Mi"
        cpu: "100m"
      requests:
        memory: "25Mi"
        cpu: "100m"

  # ------------------------- Init Container -----------------------------------
  mainContainer:
    pullPolicy: "IfNotPresent"
    registry: {}
    registryPort: {}
    name: "vulas/vulnerability-assessment-tool-patch-lib-analyzer"
    # _n_ image.mainContainer.tag
    # _i_
    #     Vulas versioning follows semver
    #     Footprint:
    #     - size: 140.48MB
    tag: "3.1.7-SNAPSHOT"

    securityContext:
      runAsUser: 12300
      runAsGroup: 12300
      privileged: false
      readOnlyRootFilesystem: false
      capabilities:
        drop:
          - ALL
        add:
          - DAC_OVERRIDE
          - SYS_TIME
          - NET_ADMIN

    resources:
      limits:
        memory: "4Gi"
        cpu: "1000m"
      requests:
        memory: "1Gi"
        cpu: "500m"


#================================= Resources =======================================
# RWO is possible but mounting an nfs with RWM
# allows patcheval caches to share the same data
# thus allowing for a gain in performance
persistentVolume: {}
  # storage: "1Gi"
  # mountPath: /patcheval-data
  # nfs:
  #   # _n_ persistentVolume.nfs.server
  #   # _i_
  #   #   nfs can be set to {} and it will automatically be
  #   #   updated as to the accessMode
  #   server: ::
  #   path: /share

livenessProbe:
  # _n_ livenessProbe.enabled
  # _i_
  # Overall time before container is considered unready by k8s :
  # initialDelaySeconds + ((periodSeconds + timeoutSeconds) * successThreshold)
  # = 80s ~= 1.3*min
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 20
  timeoutSeconds: 5
  failureThreshold: 5
